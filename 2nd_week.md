# 2nd_week
[TOC]  

---
## 类
1. C++的类实际上就是C中的`struct`实现的。
2. `struct`默认成员是`public`；`class`默认成员是`private`。

---
## 类成员的可访问范围
1. 三个关键字
  - `private`：私有成员，只有这个类的成员函数才能访问。
  - `protected`：保护成员，只有这个类或者其继承可以访问。
  - `public`：公有成员，可以在任何地方访问。
2. `private`是针对类，而不是针对单独的对象，即同一个类的不同对象，仍可以通过成员函数来访问到`private`的成员。
    ```C++
    //example.
    class A {
    private:
    	int i;//i在这里是private的.
    public:
    	A(int x) { i = x; }
    	void g(A* p) { i = p->i; } //利用这个函数访问同一个类的对象的i.
    	void showI() { cout << i << endl; }
    };
    int main()
    {
    	A a1(10);
    	A a2(100);
    	a1.g(&a2);
    	a1.showI();
    }
    //输出结果是：100，即a1的i成功地用a2的i的值赋值。
    ```
3. C++的OOP特性仅存在于源代码级别。所以，像`private`的限制仅存在到编译时刻为止。
4. 设置私有成员的机制叫“隐藏”，目的是强制对成员变量的访问一定要通过成员函数进行。如此，以后成员变量的属性发生改变时，只需修改成员函数以适应，而不用去修改所有直接访问成员的语句。
---
## 构造函数 constructor
1. 它也属于成员函数，属于`public`。函数名字与类名相同，无类型，不能有返回值。可重载。
2. 作用：对对象进行初始化，比如给成员变量赋值。
    > 对象生成时自动调用构造函数进行初始化，对象一旦生成，就再也不能在其上执行构造函数。
3. 不写构造函数，编译器默认生成一个**无参**的构造函数。如果定义了构造函数，*编译器不生成默认的无参构造函数。*
    > 这个确实是这样的，可以很简单地验证一下。
4. 对定义的**对象数组**进行初始化
    ```C++
    class A
    {
        public:
            A(){}                //(1)
            A(int x){...}        //(2)
            A(int x, int y){...} //(3)
    };
    int main()
    {
        A arr1[3] = {1, A(2,3)};//分别使用(2)(3)(1)进行初始化
        A arr2[3] = {A(1,2), A(3,4)};//分别使用(3)(3)(1)进行初始化
        A* pArr[3] = {new A(1,2), new A(3)};
        //此处是给对象指针开辟空间，注意使用new
        //所以此处实际上只对前两个进行了初始化，除非使用new A()，否则不会初始化。
    }
    ```
5. 初始化列表（`Initializer List`）-->其早于构造函数，在构造函数之前就执行了。
    ```C++
    //1.在构造函数里初始化成员变量
    A::A(int x){i = x;}
    //2.使用初始化列表
    A::A(int x, int y, ...):i(x), j(y), ...{...}
    ```
    初始化列表中的参数可以是任意复杂的表达式，可以包括函数、变量，只要表达式中的函数或变量有定义就行。（可以看看其在`3th_week`的封闭类中的应用）
    > Tips：建议类中所有成员都用初始化列表来初始化。
---

## 拷贝（复制）构造函数  copy constructor
1. 第一个参数是**自身类的引用**，且任何额外参数都有默认值，则此构造函数为**拷贝构造函数**。
2. 编译器仍然会在我们没有编写拷贝构造函数时，自动生成复制构造函数。  
    > 注意：默认（无参）构造函数不一定存在，但拷贝构造函数总是会存在，即如果定义了其他构造函数，编译器仍然会生成拷贝构造函数。
3. 这个函数的本意就是完成对于`对象`的拷贝，当然我们也可以在自己编写的拷贝构造函数中不实现拷贝的功能，但同时这个类的对象就不能进行拷贝初始化了。  
    ```C++
    class A {
    private:
    	int i;
    public:
    	A(int x) { i = x; }
    	A(const A& a)
    	{
    		cout << "copy constructor." << endl;
    	}
    	void showI() { cout << i << endl; }
    };
    int main()
    {
        A a(10);
        A b(a);
    }
    //结果：对象b的初始化过程中会输出语句，
    //     但是由于自己编写的拷贝构造函数中没有实现相关拷贝功能，
    //     所以实际上对象b中的i是一个随机值，并没有从对象a中拷贝过来。
    ```
4. 总结：拷贝构造函数起作用的三种情况
    1. 用一个对象去初始化同类的另一个对象。
    2. 将一个对象作为实参传递给一个**非引用类型**的形参时。
        > Tips：
        > - 建议使用**引用类型**来作为形参(`A& a`)，以此**减小开销**。  
        > - 同时，如果希望传入的对象中的值不被改变，可以使用`const`，防止函数中某些操作修改其值。
         ```C++
         //此处使用上文的class A
         //函数func的形参不是引用类型的.
         void func(A a)
         {
             cout<<"func called."<<endl;
             a.showI();
         }
         int main()
         {
             A x(10);
             func(x);
         }
         //结果：可以看到拷贝构造函数被执行，但是由于自己写的拷贝构造函数
         //      中没有实现拷贝功能，所以在func中读取到的i值为随机值。
         ```
    3. 从一个返回类型为非引用类型的函数返回一个对象。
          ```C++
          //此处使用上文的class A
          A func()
          {
              A b(4);
              return b;
          }
          int main()
          {
              func.showI();
          }
          //结果:可以看到拷贝构造函数被执行。同样的，func函数返回的对象中的
          //     i也是随机值。
          ```
5. 概念补充：直接初始化 & 拷贝初始化  
    1. 使用`等号=`初始化一个变量，属于拷贝初始化。不使用的话，就属于直接初始化。  
    2. 当我们使用**直接初始化**时，实际上是要求编译器使用**普通的函数匹配**来选择与我们提供的参数最匹配的构造函数；而当我们使用**拷贝初始化**时，实际上是要求编译器将**右侧的运算对象**拷贝到正在初始化的对象中，如果需要的话，还需要进行类型转换。  
    3. 例子
         ```C++
         string s("czdpzc");   //直接
         string s2 = s;        //拷贝
         string s3(s2);        //直接
         string s4(10,'#');    //直接
         string s5 = "czdpzc"; //拷贝
         ```
---
## 类型转换构造函数
1. 单参数的构造函数（single-argument constructors）实现类型转换。
2. 其实之前编写的构造函数就有这种类型。这一次的关键在于可以直接用`等号=`触发类型转换构造函数。
    ```C++
    class A {
    private:
    	int i;
    	string str;
    public:
    	A(int x) { i = x; }
    	A(string s) { str = s; }
    	void showI() { cout << i << endl; }
    	void showStr() { cout << str << endl; }
    };
    int main()
    {
        A x(10);//普通的初始化对象
        A y = 100;//编译器会调用相应类型的构造函数来将100转换成一个临时的A类对象
        A z = (string)"czdpzc";//同理
    }
    ```
---
## 析构函数  destructors
1. `~A(){...}`析构函数在对象消亡的时候起作用。
2. 一个类最多**只能有一个**析构函数。
3. 析构函数没有参数和返回值。
4. 我们亲爱的编译器仍然会在我们没有编写析构函数的时候，生成一个缺省的析构函数。┐(‘～`；)┌ 
5. 最普通的作用：在析构函数中`delete`这个类中动态分配的存储空间。
6. `delete`对象时，其实就触发了其析构函数。
7. 注意**临时对象**的消亡所触发的析构函数。
8. 例子
    ```C++
    class A 
    {
        ~A(){cout<<"destructor."<<endl;}
    };
    A obj;
    A func(A a)
    {
        return a;
    }
    int main()
    {
        obj = func(obj);//函数中形参1次；func返回值作为临时对象1次。
        return 0;       //obj消亡1次。
    }
    //结果：析构函数在这段代码中被调用3次。
    ```












