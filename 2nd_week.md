# 2nd_week
#### 类
1. C++的类实际上就是C中的`struct`实现的。
2. `struct`默认成员是`public`；`class`默认成员是`private`。

---
#### 类成员的可访问范围
1. 三个关键字
  - `private`：私有成员，只有这个类的成员函数才能访问。
  - `protected`：保护成员，只有这个类或者其继承可以访问。
  - `public`：公有成员，可以在任何地方访问。
2. `private`是针对类，而不是针对单独的对象，即同一个类的不同对象，仍可以通过成员函数来访问到`private`的成员。
    ```C++
    //example.
    class A {
    private:
    	int i;//i在这里是private的.
    public:
    	A(int x) { i = x; }
    	void g(A* p) { i = p->i; } //利用这个函数访问同一个类的对象的i.
    	void showI() { cout << i << endl; }
    };
    int main()
    {
    	A a1(10);
    	A a2(100);
    	a1.g(&a2);
    	a1.showI();
    }
    //输出结果是：100，即a1的i成功地用a2的i的值赋值。
    ```
3. C++的OOP特性仅存在于源代码级别。所以，像`private`的限制仅存在到编译时刻为止。
4. 设置私有成员的机制叫“隐藏”，目的是强制对成员变量的访问一定要通过成员函数进行。如此，以后成员变量的属性发生改变时，只需修改成员函数以适应，而不用去修改所有直接访问成员的语句。
---
#### 构造函数 constructor
1. 它也属于成员函数，属于`public`。函数名字与类名相同，无类型，不能有返回值。可重载。
2. 作用：对对象进行初始化，比如给成员变量赋值。
    > 对象生成时自动调用构造函数进行初始化，对象一旦生成，就再也不能在其上执行构造函数。
3. 不写构造函数，编译器默认生成一个**无参**的构造函数。如果定义了构造函数，*编译器不生成默认的无参构造函数。*
    > 这个确实是这样的，可以很简单地验证一下。
4. 对定义的**对象数组**进行初始化
    ```C++
    class A
    {
        public:
            A(){}                //(1)
            A(int x){...}        //(2)
            A(int x, int y){...} //(3)
    };
    int main()
    {
        A arr1[3] = {1, A(2,3)};//分别使用(2)(3)(1)进行初始化
        A arr2[3] = {A(1,2), A(3,4)};//分别使用(3)(3)(1)进行初始化
        A* pArr[3] = {new A(1,2), new A(3)};
        //此处是给对象指针开辟空间，注意使用new
        //所以此处实际上只对前两个进行了初始化，除非使用new A()，否则不会初始化。
    }
    ```
5. 初始化列表（`Initializer List`）-->其早于构造函数，在构造函数之前就执行了。
    ```C++
    //1.在构造函数里初始化成员变量
    A::A(int x){i = x;}
    //2.使用初始化列表
    A::A(int x):i(x){...}
    ```
    > Tips：建议类中所有成员都用初始化列表来初始化。
6. 拷贝（复制）构造函数（`copy constructor`）
    1. 第一个参数是**自身类的引用**，且任何额外参数都有默认值，则此构造函数为**拷贝构造函数**。
    2. 编译器仍然会在我们没有编写拷贝构造函数时，自动生成复制构造函数。  
        > 注意：默认（无参）构造函数不一定存在，但拷贝构造函数总是会存在，即如果定义了其他构造函数，编译器仍然会生成拷贝构造函数。
    3. 这个函数的本意就是完成对于`对象`的拷贝，当然我们也可以在自己编写的拷贝构造函数中不实现拷贝的功能，但同时这个类的对象就不能进行拷贝初始化了。  
        ```C++
        class A {
        private:
        	int i;
        public:
        	A(int x) { i = x; }
        	A(const A& a)
        	{
        		cout << "copy constructor." << endl;
        	}
        	void showI() { cout << i << endl; }
        };
        int main()
        {
            A a(10);
            A b(a);
        }
        //结果：对象b的初始化过程中会输出语句，
        //     但是由于自己编写的拷贝构造函数中没有实现相关拷贝功能，
        //     所以实际上对象b中的i是一个随机值，并没有从对象a中拷贝过来。
        ```
     4. 总结：拷贝构造函数起作用的三种情况
         1. 用一个对象去初始化同类的另一个对象。
         2. 将一个对象作为实参传递给一个**非引用类型**的形参时。
            > Tips：
            > - 建议使用**引用类型**来作为形参(`A& a`)，以此**减小开销**。  
            > - 同时，如果希望传入的对象中的值不被改变，可以使用`const`，防止函数中某些操作修改其值。
             ```C++
             //此处使用上文的class A
             //函数func的形参不是引用类型的.
             void func(A a)
             {
                 cout<<"func called."<<endl;
                 a.showI();
             }
             int main()
             {
                 A x(10);
                 func(x);
             }
             //结果：可以看到拷贝构造函数被执行，但是由于自己写的拷贝构造函数
             //      中没有实现拷贝功能，所以在func中读取到的i值为随机值。
             ```
          3. 从一个返回类型为非引用类型的函数返回一个对象。
              ```C++
              //此处使用上文的class A
              A func()
              {
                  A b(4);
                  return b;
              }
              int main()
              {
                  func.showI();
              }
              //结果:可以看到拷贝构造函数被执行。同样的，func函数返回的对象中的
              //     i也是随机值。
              ```
    > 概念补充：直接初始化 & 拷贝初始化  
    > 1. 使用`等号=`初始化一个变量，属于拷贝初始化。不使用的话，就属于直接初始化。  
    > 2. 当我们使用**直接初始化**时，实际上是要求编译器使用**普通的函数匹配**来选择与我们提供的参数最匹配的构造函数；而当我们使用**拷贝初始化**时，实际上是要求编译器将**右侧的运算对象**拷贝到正在初始化的对象中，如果需要的话，还需要进行类型转换。  
    > 3. 例子
    >     ```C++
    >     string s("czdpzc");   //直接
    >     string s2 = s;        //拷贝
    >     string s3(s2);        //直接
    >     string s4(10,'#');    //直接
    >     string s5 = "czdpzc"; //拷贝
    >     ```
---
#### 类型转换构造函数
1. 其实之前编写的构造函数就有这种类型。这一次的关键在于可以直接用`等号=`触发类型转换构造函数。
    ```C++
    class A {
    private:
    	int i;
    	string str;
    public:
    	A(int x) { i = x; }
    	A(string s) { str = s; }
    	void showI() { cout << i << endl; }
    	void showStr() { cout << str << endl; }
    };
    int main()
    {
        A x(10);//普通的初始化对象
        A y = 100;//编译器会调用相应类型的构造函数来将100转换成一个临时的A类对象
        A z = (string)"czdpzc";//同理
    }
    ```
---
#### 析构函数（destructors）
1. `~A(){...}`析构函数在对象消亡的时候起作用。
2. 一个类最多**只能有一个**析构函数。
3. 析构函数没有参数和返回值。
4. 我们亲爱的编译器仍然会在我们没有编写析构函数的时候，生成一个缺省的析构函数。┐(‘～`；)┌ 
5. 最普通的作用：在析构函数中`delete`这个类中动态分配的存储空间。
6. `delete`对象时，其实就触发了其析构函数。
7. 注意**临时对象**的消亡所触发的析构函数。
8. 例子
    ```C++
    class A 
    {
        ~A(){cout<<"destructor."<<endl;}
    };
    A obj;
    A func(A a)
    {
        return a;
    }
    int main()
    {
        obj = func(obj);//函数中形参1次；func返回值作为临时对象1次。
        return 0;       //obj消亡1次。
    }
    //结果：析构函数在这段代码中被调用3次。
    ```